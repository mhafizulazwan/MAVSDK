// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: winch/winch.proto
#ifndef GRPC_winch_2fwinch_2eproto__INCLUDED
#define GRPC_winch_2fwinch_2eproto__INCLUDED

#include "winch/winch.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace mavsdk {
namespace rpc {
namespace winch {

//
// Allows users to send winch actions, as well as receive status information from winch systems.
//
class WinchService final {
 public:
  static constexpr char const* service_full_name() {
    return "mavsdk.rpc.winch.WinchService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Subscribe to 'winch status' updates.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::mavsdk::rpc::winch::StatusResponse>> SubscribeStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::SubscribeStatusRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::mavsdk::rpc::winch::StatusResponse>>(SubscribeStatusRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::winch::StatusResponse>> AsyncSubscribeStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::SubscribeStatusRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::winch::StatusResponse>>(AsyncSubscribeStatusRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::winch::StatusResponse>> PrepareAsyncSubscribeStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::SubscribeStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::winch::StatusResponse>>(PrepareAsyncSubscribeStatusRaw(context, request, cq));
    }
    //
    // Allow motor to freewheel.
    virtual ::grpc::Status Relax(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RelaxRequest& request, ::mavsdk::rpc::winch::RelaxResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::RelaxResponse>> AsyncRelax(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RelaxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::RelaxResponse>>(AsyncRelaxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::RelaxResponse>> PrepareAsyncRelax(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RelaxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::RelaxResponse>>(PrepareAsyncRelaxRaw(context, request, cq));
    }
    //
    // Wind or unwind specified length of line, optionally using specified rate.
    virtual ::grpc::Status RelativeLengthControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RelativeLengthControlRequest& request, ::mavsdk::rpc::winch::RelativeLengthControlResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::RelativeLengthControlResponse>> AsyncRelativeLengthControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RelativeLengthControlRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::RelativeLengthControlResponse>>(AsyncRelativeLengthControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::RelativeLengthControlResponse>> PrepareAsyncRelativeLengthControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RelativeLengthControlRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::RelativeLengthControlResponse>>(PrepareAsyncRelativeLengthControlRaw(context, request, cq));
    }
    //
    // Wind or unwind line at specified rate.
    virtual ::grpc::Status RateControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RateControlRequest& request, ::mavsdk::rpc::winch::RateControlResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::RateControlResponse>> AsyncRateControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RateControlRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::RateControlResponse>>(AsyncRateControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::RateControlResponse>> PrepareAsyncRateControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RateControlRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::RateControlResponse>>(PrepareAsyncRateControlRaw(context, request, cq));
    }
    //
    // Perform the locking sequence to relieve motor while in the fully retracted position.
    virtual ::grpc::Status Lock(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LockRequest& request, ::mavsdk::rpc::winch::LockResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::LockResponse>> AsyncLock(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::LockResponse>>(AsyncLockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::LockResponse>> PrepareAsyncLock(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::LockResponse>>(PrepareAsyncLockRaw(context, request, cq));
    }
    //
    // Sequence of drop, slow down, touch down, reel up, lock.
    virtual ::grpc::Status Deliver(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::DeliverRequest& request, ::mavsdk::rpc::winch::DeliverResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::DeliverResponse>> AsyncDeliver(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::DeliverRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::DeliverResponse>>(AsyncDeliverRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::DeliverResponse>> PrepareAsyncDeliver(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::DeliverRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::DeliverResponse>>(PrepareAsyncDeliverRaw(context, request, cq));
    }
    //
    // Engage motor and hold current position.
    virtual ::grpc::Status Hold(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::HoldRequest& request, ::mavsdk::rpc::winch::HoldResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::HoldResponse>> AsyncHold(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::HoldRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::HoldResponse>>(AsyncHoldRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::HoldResponse>> PrepareAsyncHold(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::HoldRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::HoldResponse>>(PrepareAsyncHoldRaw(context, request, cq));
    }
    //
    // Return the reel to the fully retracted position.
    virtual ::grpc::Status Retract(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RetractRequest& request, ::mavsdk::rpc::winch::RetractResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::RetractResponse>> AsyncRetract(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RetractRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::RetractResponse>>(AsyncRetractRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::RetractResponse>> PrepareAsyncRetract(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RetractRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::RetractResponse>>(PrepareAsyncRetractRaw(context, request, cq));
    }
    //
    // Load the reel with line.
    //
    // The winch will calculate the total loaded length and stop when the tension exceeds a threshold.
    virtual ::grpc::Status LoadLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LoadLineRequest& request, ::mavsdk::rpc::winch::LoadLineResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::LoadLineResponse>> AsyncLoadLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LoadLineRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::LoadLineResponse>>(AsyncLoadLineRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::LoadLineResponse>> PrepareAsyncLoadLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LoadLineRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::LoadLineResponse>>(PrepareAsyncLoadLineRaw(context, request, cq));
    }
    //
    // Spool out the entire length of the line.
    virtual ::grpc::Status AbandonLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::AbandonLineRequest& request, ::mavsdk::rpc::winch::AbandonLineResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::AbandonLineResponse>> AsyncAbandonLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::AbandonLineRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::AbandonLineResponse>>(AsyncAbandonLineRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::AbandonLineResponse>> PrepareAsyncAbandonLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::AbandonLineRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::AbandonLineResponse>>(PrepareAsyncAbandonLineRaw(context, request, cq));
    }
    //
    // Spools out just enough to present the hook to the user to load the payload.
    virtual ::grpc::Status LoadPayload(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LoadPayloadRequest& request, ::mavsdk::rpc::winch::LoadPayloadResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::LoadPayloadResponse>> AsyncLoadPayload(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LoadPayloadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::LoadPayloadResponse>>(AsyncLoadPayloadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::LoadPayloadResponse>> PrepareAsyncLoadPayload(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LoadPayloadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::LoadPayloadResponse>>(PrepareAsyncLoadPayloadRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Subscribe to 'winch status' updates.
      virtual void SubscribeStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::SubscribeStatusRequest* request, ::grpc::ClientReadReactor< ::mavsdk::rpc::winch::StatusResponse>* reactor) = 0;
      //
      // Allow motor to freewheel.
      virtual void Relax(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RelaxRequest* request, ::mavsdk::rpc::winch::RelaxResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Relax(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RelaxRequest* request, ::mavsdk::rpc::winch::RelaxResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Wind or unwind specified length of line, optionally using specified rate.
      virtual void RelativeLengthControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RelativeLengthControlRequest* request, ::mavsdk::rpc::winch::RelativeLengthControlResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RelativeLengthControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RelativeLengthControlRequest* request, ::mavsdk::rpc::winch::RelativeLengthControlResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Wind or unwind line at specified rate.
      virtual void RateControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RateControlRequest* request, ::mavsdk::rpc::winch::RateControlResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RateControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RateControlRequest* request, ::mavsdk::rpc::winch::RateControlResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Perform the locking sequence to relieve motor while in the fully retracted position.
      virtual void Lock(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LockRequest* request, ::mavsdk::rpc::winch::LockResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Lock(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LockRequest* request, ::mavsdk::rpc::winch::LockResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Sequence of drop, slow down, touch down, reel up, lock.
      virtual void Deliver(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::DeliverRequest* request, ::mavsdk::rpc::winch::DeliverResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Deliver(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::DeliverRequest* request, ::mavsdk::rpc::winch::DeliverResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Engage motor and hold current position.
      virtual void Hold(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::HoldRequest* request, ::mavsdk::rpc::winch::HoldResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Hold(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::HoldRequest* request, ::mavsdk::rpc::winch::HoldResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Return the reel to the fully retracted position.
      virtual void Retract(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RetractRequest* request, ::mavsdk::rpc::winch::RetractResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Retract(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RetractRequest* request, ::mavsdk::rpc::winch::RetractResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Load the reel with line.
      //
      // The winch will calculate the total loaded length and stop when the tension exceeds a threshold.
      virtual void LoadLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LoadLineRequest* request, ::mavsdk::rpc::winch::LoadLineResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LoadLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LoadLineRequest* request, ::mavsdk::rpc::winch::LoadLineResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Spool out the entire length of the line.
      virtual void AbandonLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::AbandonLineRequest* request, ::mavsdk::rpc::winch::AbandonLineResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AbandonLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::AbandonLineRequest* request, ::mavsdk::rpc::winch::AbandonLineResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      //
      // Spools out just enough to present the hook to the user to load the payload.
      virtual void LoadPayload(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LoadPayloadRequest* request, ::mavsdk::rpc::winch::LoadPayloadResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LoadPayload(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LoadPayloadRequest* request, ::mavsdk::rpc::winch::LoadPayloadResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientReaderInterface< ::mavsdk::rpc::winch::StatusResponse>* SubscribeStatusRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::SubscribeStatusRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::winch::StatusResponse>* AsyncSubscribeStatusRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::SubscribeStatusRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::winch::StatusResponse>* PrepareAsyncSubscribeStatusRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::SubscribeStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::RelaxResponse>* AsyncRelaxRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RelaxRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::RelaxResponse>* PrepareAsyncRelaxRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RelaxRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::RelativeLengthControlResponse>* AsyncRelativeLengthControlRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RelativeLengthControlRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::RelativeLengthControlResponse>* PrepareAsyncRelativeLengthControlRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RelativeLengthControlRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::RateControlResponse>* AsyncRateControlRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RateControlRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::RateControlResponse>* PrepareAsyncRateControlRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RateControlRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::LockResponse>* AsyncLockRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::LockResponse>* PrepareAsyncLockRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::DeliverResponse>* AsyncDeliverRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::DeliverRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::DeliverResponse>* PrepareAsyncDeliverRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::DeliverRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::HoldResponse>* AsyncHoldRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::HoldRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::HoldResponse>* PrepareAsyncHoldRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::HoldRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::RetractResponse>* AsyncRetractRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RetractRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::RetractResponse>* PrepareAsyncRetractRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RetractRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::LoadLineResponse>* AsyncLoadLineRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LoadLineRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::LoadLineResponse>* PrepareAsyncLoadLineRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LoadLineRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::AbandonLineResponse>* AsyncAbandonLineRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::AbandonLineRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::AbandonLineResponse>* PrepareAsyncAbandonLineRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::AbandonLineRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::LoadPayloadResponse>* AsyncLoadPayloadRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LoadPayloadRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::winch::LoadPayloadResponse>* PrepareAsyncLoadPayloadRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LoadPayloadRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    std::unique_ptr< ::grpc::ClientReader< ::mavsdk::rpc::winch::StatusResponse>> SubscribeStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::SubscribeStatusRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::mavsdk::rpc::winch::StatusResponse>>(SubscribeStatusRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::winch::StatusResponse>> AsyncSubscribeStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::SubscribeStatusRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::winch::StatusResponse>>(AsyncSubscribeStatusRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::winch::StatusResponse>> PrepareAsyncSubscribeStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::SubscribeStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::winch::StatusResponse>>(PrepareAsyncSubscribeStatusRaw(context, request, cq));
    }
    ::grpc::Status Relax(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RelaxRequest& request, ::mavsdk::rpc::winch::RelaxResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::RelaxResponse>> AsyncRelax(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RelaxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::RelaxResponse>>(AsyncRelaxRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::RelaxResponse>> PrepareAsyncRelax(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RelaxRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::RelaxResponse>>(PrepareAsyncRelaxRaw(context, request, cq));
    }
    ::grpc::Status RelativeLengthControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RelativeLengthControlRequest& request, ::mavsdk::rpc::winch::RelativeLengthControlResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::RelativeLengthControlResponse>> AsyncRelativeLengthControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RelativeLengthControlRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::RelativeLengthControlResponse>>(AsyncRelativeLengthControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::RelativeLengthControlResponse>> PrepareAsyncRelativeLengthControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RelativeLengthControlRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::RelativeLengthControlResponse>>(PrepareAsyncRelativeLengthControlRaw(context, request, cq));
    }
    ::grpc::Status RateControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RateControlRequest& request, ::mavsdk::rpc::winch::RateControlResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::RateControlResponse>> AsyncRateControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RateControlRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::RateControlResponse>>(AsyncRateControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::RateControlResponse>> PrepareAsyncRateControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RateControlRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::RateControlResponse>>(PrepareAsyncRateControlRaw(context, request, cq));
    }
    ::grpc::Status Lock(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LockRequest& request, ::mavsdk::rpc::winch::LockResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::LockResponse>> AsyncLock(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::LockResponse>>(AsyncLockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::LockResponse>> PrepareAsyncLock(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::LockResponse>>(PrepareAsyncLockRaw(context, request, cq));
    }
    ::grpc::Status Deliver(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::DeliverRequest& request, ::mavsdk::rpc::winch::DeliverResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::DeliverResponse>> AsyncDeliver(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::DeliverRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::DeliverResponse>>(AsyncDeliverRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::DeliverResponse>> PrepareAsyncDeliver(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::DeliverRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::DeliverResponse>>(PrepareAsyncDeliverRaw(context, request, cq));
    }
    ::grpc::Status Hold(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::HoldRequest& request, ::mavsdk::rpc::winch::HoldResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::HoldResponse>> AsyncHold(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::HoldRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::HoldResponse>>(AsyncHoldRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::HoldResponse>> PrepareAsyncHold(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::HoldRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::HoldResponse>>(PrepareAsyncHoldRaw(context, request, cq));
    }
    ::grpc::Status Retract(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RetractRequest& request, ::mavsdk::rpc::winch::RetractResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::RetractResponse>> AsyncRetract(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RetractRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::RetractResponse>>(AsyncRetractRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::RetractResponse>> PrepareAsyncRetract(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RetractRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::RetractResponse>>(PrepareAsyncRetractRaw(context, request, cq));
    }
    ::grpc::Status LoadLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LoadLineRequest& request, ::mavsdk::rpc::winch::LoadLineResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::LoadLineResponse>> AsyncLoadLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LoadLineRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::LoadLineResponse>>(AsyncLoadLineRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::LoadLineResponse>> PrepareAsyncLoadLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LoadLineRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::LoadLineResponse>>(PrepareAsyncLoadLineRaw(context, request, cq));
    }
    ::grpc::Status AbandonLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::AbandonLineRequest& request, ::mavsdk::rpc::winch::AbandonLineResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::AbandonLineResponse>> AsyncAbandonLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::AbandonLineRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::AbandonLineResponse>>(AsyncAbandonLineRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::AbandonLineResponse>> PrepareAsyncAbandonLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::AbandonLineRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::AbandonLineResponse>>(PrepareAsyncAbandonLineRaw(context, request, cq));
    }
    ::grpc::Status LoadPayload(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LoadPayloadRequest& request, ::mavsdk::rpc::winch::LoadPayloadResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::LoadPayloadResponse>> AsyncLoadPayload(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LoadPayloadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::LoadPayloadResponse>>(AsyncLoadPayloadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::LoadPayloadResponse>> PrepareAsyncLoadPayload(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LoadPayloadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::LoadPayloadResponse>>(PrepareAsyncLoadPayloadRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void SubscribeStatus(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::SubscribeStatusRequest* request, ::grpc::ClientReadReactor< ::mavsdk::rpc::winch::StatusResponse>* reactor) override;
      void Relax(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RelaxRequest* request, ::mavsdk::rpc::winch::RelaxResponse* response, std::function<void(::grpc::Status)>) override;
      void Relax(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RelaxRequest* request, ::mavsdk::rpc::winch::RelaxResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RelativeLengthControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RelativeLengthControlRequest* request, ::mavsdk::rpc::winch::RelativeLengthControlResponse* response, std::function<void(::grpc::Status)>) override;
      void RelativeLengthControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RelativeLengthControlRequest* request, ::mavsdk::rpc::winch::RelativeLengthControlResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RateControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RateControlRequest* request, ::mavsdk::rpc::winch::RateControlResponse* response, std::function<void(::grpc::Status)>) override;
      void RateControl(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RateControlRequest* request, ::mavsdk::rpc::winch::RateControlResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Lock(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LockRequest* request, ::mavsdk::rpc::winch::LockResponse* response, std::function<void(::grpc::Status)>) override;
      void Lock(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LockRequest* request, ::mavsdk::rpc::winch::LockResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Deliver(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::DeliverRequest* request, ::mavsdk::rpc::winch::DeliverResponse* response, std::function<void(::grpc::Status)>) override;
      void Deliver(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::DeliverRequest* request, ::mavsdk::rpc::winch::DeliverResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Hold(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::HoldRequest* request, ::mavsdk::rpc::winch::HoldResponse* response, std::function<void(::grpc::Status)>) override;
      void Hold(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::HoldRequest* request, ::mavsdk::rpc::winch::HoldResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Retract(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RetractRequest* request, ::mavsdk::rpc::winch::RetractResponse* response, std::function<void(::grpc::Status)>) override;
      void Retract(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RetractRequest* request, ::mavsdk::rpc::winch::RetractResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void LoadLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LoadLineRequest* request, ::mavsdk::rpc::winch::LoadLineResponse* response, std::function<void(::grpc::Status)>) override;
      void LoadLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LoadLineRequest* request, ::mavsdk::rpc::winch::LoadLineResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void AbandonLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::AbandonLineRequest* request, ::mavsdk::rpc::winch::AbandonLineResponse* response, std::function<void(::grpc::Status)>) override;
      void AbandonLine(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::AbandonLineRequest* request, ::mavsdk::rpc::winch::AbandonLineResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void LoadPayload(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LoadPayloadRequest* request, ::mavsdk::rpc::winch::LoadPayloadResponse* response, std::function<void(::grpc::Status)>) override;
      void LoadPayload(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LoadPayloadRequest* request, ::mavsdk::rpc::winch::LoadPayloadResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientReader< ::mavsdk::rpc::winch::StatusResponse>* SubscribeStatusRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::SubscribeStatusRequest& request) override;
    ::grpc::ClientAsyncReader< ::mavsdk::rpc::winch::StatusResponse>* AsyncSubscribeStatusRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::SubscribeStatusRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::mavsdk::rpc::winch::StatusResponse>* PrepareAsyncSubscribeStatusRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::SubscribeStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::RelaxResponse>* AsyncRelaxRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RelaxRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::RelaxResponse>* PrepareAsyncRelaxRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RelaxRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::RelativeLengthControlResponse>* AsyncRelativeLengthControlRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RelativeLengthControlRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::RelativeLengthControlResponse>* PrepareAsyncRelativeLengthControlRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RelativeLengthControlRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::RateControlResponse>* AsyncRateControlRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RateControlRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::RateControlResponse>* PrepareAsyncRateControlRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RateControlRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::LockResponse>* AsyncLockRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::LockResponse>* PrepareAsyncLockRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::DeliverResponse>* AsyncDeliverRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::DeliverRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::DeliverResponse>* PrepareAsyncDeliverRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::DeliverRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::HoldResponse>* AsyncHoldRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::HoldRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::HoldResponse>* PrepareAsyncHoldRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::HoldRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::RetractResponse>* AsyncRetractRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RetractRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::RetractResponse>* PrepareAsyncRetractRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::RetractRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::LoadLineResponse>* AsyncLoadLineRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LoadLineRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::LoadLineResponse>* PrepareAsyncLoadLineRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LoadLineRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::AbandonLineResponse>* AsyncAbandonLineRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::AbandonLineRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::AbandonLineResponse>* PrepareAsyncAbandonLineRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::AbandonLineRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::LoadPayloadResponse>* AsyncLoadPayloadRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LoadPayloadRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::winch::LoadPayloadResponse>* PrepareAsyncLoadPayloadRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::winch::LoadPayloadRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_SubscribeStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_Relax_;
    const ::grpc::internal::RpcMethod rpcmethod_RelativeLengthControl_;
    const ::grpc::internal::RpcMethod rpcmethod_RateControl_;
    const ::grpc::internal::RpcMethod rpcmethod_Lock_;
    const ::grpc::internal::RpcMethod rpcmethod_Deliver_;
    const ::grpc::internal::RpcMethod rpcmethod_Hold_;
    const ::grpc::internal::RpcMethod rpcmethod_Retract_;
    const ::grpc::internal::RpcMethod rpcmethod_LoadLine_;
    const ::grpc::internal::RpcMethod rpcmethod_AbandonLine_;
    const ::grpc::internal::RpcMethod rpcmethod_LoadPayload_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Subscribe to 'winch status' updates.
    virtual ::grpc::Status SubscribeStatus(::grpc::ServerContext* context, const ::mavsdk::rpc::winch::SubscribeStatusRequest* request, ::grpc::ServerWriter< ::mavsdk::rpc::winch::StatusResponse>* writer);
    //
    // Allow motor to freewheel.
    virtual ::grpc::Status Relax(::grpc::ServerContext* context, const ::mavsdk::rpc::winch::RelaxRequest* request, ::mavsdk::rpc::winch::RelaxResponse* response);
    //
    // Wind or unwind specified length of line, optionally using specified rate.
    virtual ::grpc::Status RelativeLengthControl(::grpc::ServerContext* context, const ::mavsdk::rpc::winch::RelativeLengthControlRequest* request, ::mavsdk::rpc::winch::RelativeLengthControlResponse* response);
    //
    // Wind or unwind line at specified rate.
    virtual ::grpc::Status RateControl(::grpc::ServerContext* context, const ::mavsdk::rpc::winch::RateControlRequest* request, ::mavsdk::rpc::winch::RateControlResponse* response);
    //
    // Perform the locking sequence to relieve motor while in the fully retracted position.
    virtual ::grpc::Status Lock(::grpc::ServerContext* context, const ::mavsdk::rpc::winch::LockRequest* request, ::mavsdk::rpc::winch::LockResponse* response);
    //
    // Sequence of drop, slow down, touch down, reel up, lock.
    virtual ::grpc::Status Deliver(::grpc::ServerContext* context, const ::mavsdk::rpc::winch::DeliverRequest* request, ::mavsdk::rpc::winch::DeliverResponse* response);
    //
    // Engage motor and hold current position.
    virtual ::grpc::Status Hold(::grpc::ServerContext* context, const ::mavsdk::rpc::winch::HoldRequest* request, ::mavsdk::rpc::winch::HoldResponse* response);
    //
    // Return the reel to the fully retracted position.
    virtual ::grpc::Status Retract(::grpc::ServerContext* context, const ::mavsdk::rpc::winch::RetractRequest* request, ::mavsdk::rpc::winch::RetractResponse* response);
    //
    // Load the reel with line.
    //
    // The winch will calculate the total loaded length and stop when the tension exceeds a threshold.
    virtual ::grpc::Status LoadLine(::grpc::ServerContext* context, const ::mavsdk::rpc::winch::LoadLineRequest* request, ::mavsdk::rpc::winch::LoadLineResponse* response);
    //
    // Spool out the entire length of the line.
    virtual ::grpc::Status AbandonLine(::grpc::ServerContext* context, const ::mavsdk::rpc::winch::AbandonLineRequest* request, ::mavsdk::rpc::winch::AbandonLineResponse* response);
    //
    // Spools out just enough to present the hook to the user to load the payload.
    virtual ::grpc::Status LoadPayload(::grpc::ServerContext* context, const ::mavsdk::rpc::winch::LoadPayloadRequest* request, ::mavsdk::rpc::winch::LoadPayloadResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_SubscribeStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubscribeStatus() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_SubscribeStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeStatus(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::SubscribeStatusRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::winch::StatusResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeStatus(::grpc::ServerContext* context, ::mavsdk::rpc::winch::SubscribeStatusRequest* request, ::grpc::ServerAsyncWriter< ::mavsdk::rpc::winch::StatusResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Relax : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Relax() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_Relax() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Relax(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::RelaxRequest* /*request*/, ::mavsdk::rpc::winch::RelaxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRelax(::grpc::ServerContext* context, ::mavsdk::rpc::winch::RelaxRequest* request, ::grpc::ServerAsyncResponseWriter< ::mavsdk::rpc::winch::RelaxResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RelativeLengthControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RelativeLengthControl() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_RelativeLengthControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RelativeLengthControl(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::RelativeLengthControlRequest* /*request*/, ::mavsdk::rpc::winch::RelativeLengthControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRelativeLengthControl(::grpc::ServerContext* context, ::mavsdk::rpc::winch::RelativeLengthControlRequest* request, ::grpc::ServerAsyncResponseWriter< ::mavsdk::rpc::winch::RelativeLengthControlResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RateControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RateControl() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_RateControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RateControl(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::RateControlRequest* /*request*/, ::mavsdk::rpc::winch::RateControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRateControl(::grpc::ServerContext* context, ::mavsdk::rpc::winch::RateControlRequest* request, ::grpc::ServerAsyncResponseWriter< ::mavsdk::rpc::winch::RateControlResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Lock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Lock() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_Lock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Lock(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::LockRequest* /*request*/, ::mavsdk::rpc::winch::LockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLock(::grpc::ServerContext* context, ::mavsdk::rpc::winch::LockRequest* request, ::grpc::ServerAsyncResponseWriter< ::mavsdk::rpc::winch::LockResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Deliver : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Deliver() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_Deliver() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Deliver(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::DeliverRequest* /*request*/, ::mavsdk::rpc::winch::DeliverResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeliver(::grpc::ServerContext* context, ::mavsdk::rpc::winch::DeliverRequest* request, ::grpc::ServerAsyncResponseWriter< ::mavsdk::rpc::winch::DeliverResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Hold : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Hold() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_Hold() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Hold(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::HoldRequest* /*request*/, ::mavsdk::rpc::winch::HoldResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHold(::grpc::ServerContext* context, ::mavsdk::rpc::winch::HoldRequest* request, ::grpc::ServerAsyncResponseWriter< ::mavsdk::rpc::winch::HoldResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Retract : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Retract() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_Retract() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Retract(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::RetractRequest* /*request*/, ::mavsdk::rpc::winch::RetractResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRetract(::grpc::ServerContext* context, ::mavsdk::rpc::winch::RetractRequest* request, ::grpc::ServerAsyncResponseWriter< ::mavsdk::rpc::winch::RetractResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LoadLine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LoadLine() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_LoadLine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadLine(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::LoadLineRequest* /*request*/, ::mavsdk::rpc::winch::LoadLineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLoadLine(::grpc::ServerContext* context, ::mavsdk::rpc::winch::LoadLineRequest* request, ::grpc::ServerAsyncResponseWriter< ::mavsdk::rpc::winch::LoadLineResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AbandonLine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AbandonLine() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_AbandonLine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AbandonLine(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::AbandonLineRequest* /*request*/, ::mavsdk::rpc::winch::AbandonLineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAbandonLine(::grpc::ServerContext* context, ::mavsdk::rpc::winch::AbandonLineRequest* request, ::grpc::ServerAsyncResponseWriter< ::mavsdk::rpc::winch::AbandonLineResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LoadPayload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LoadPayload() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_LoadPayload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadPayload(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::LoadPayloadRequest* /*request*/, ::mavsdk::rpc::winch::LoadPayloadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLoadPayload(::grpc::ServerContext* context, ::mavsdk::rpc::winch::LoadPayloadRequest* request, ::grpc::ServerAsyncResponseWriter< ::mavsdk::rpc::winch::LoadPayloadResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_SubscribeStatus<WithAsyncMethod_Relax<WithAsyncMethod_RelativeLengthControl<WithAsyncMethod_RateControl<WithAsyncMethod_Lock<WithAsyncMethod_Deliver<WithAsyncMethod_Hold<WithAsyncMethod_Retract<WithAsyncMethod_LoadLine<WithAsyncMethod_AbandonLine<WithAsyncMethod_LoadPayload<Service > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_SubscribeStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SubscribeStatus() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackServerStreamingHandler< ::mavsdk::rpc::winch::SubscribeStatusRequest, ::mavsdk::rpc::winch::StatusResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mavsdk::rpc::winch::SubscribeStatusRequest* request) { return this->SubscribeStatus(context, request); }));
    }
    ~WithCallbackMethod_SubscribeStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeStatus(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::SubscribeStatusRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::winch::StatusResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::mavsdk::rpc::winch::StatusResponse>* SubscribeStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::winch::SubscribeStatusRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Relax : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Relax() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::RelaxRequest, ::mavsdk::rpc::winch::RelaxResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mavsdk::rpc::winch::RelaxRequest* request, ::mavsdk::rpc::winch::RelaxResponse* response) { return this->Relax(context, request, response); }));}
    void SetMessageAllocatorFor_Relax(
        ::grpc::MessageAllocator< ::mavsdk::rpc::winch::RelaxRequest, ::mavsdk::rpc::winch::RelaxResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::RelaxRequest, ::mavsdk::rpc::winch::RelaxResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Relax() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Relax(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::RelaxRequest* /*request*/, ::mavsdk::rpc::winch::RelaxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Relax(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::winch::RelaxRequest* /*request*/, ::mavsdk::rpc::winch::RelaxResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RelativeLengthControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RelativeLengthControl() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::RelativeLengthControlRequest, ::mavsdk::rpc::winch::RelativeLengthControlResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mavsdk::rpc::winch::RelativeLengthControlRequest* request, ::mavsdk::rpc::winch::RelativeLengthControlResponse* response) { return this->RelativeLengthControl(context, request, response); }));}
    void SetMessageAllocatorFor_RelativeLengthControl(
        ::grpc::MessageAllocator< ::mavsdk::rpc::winch::RelativeLengthControlRequest, ::mavsdk::rpc::winch::RelativeLengthControlResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::RelativeLengthControlRequest, ::mavsdk::rpc::winch::RelativeLengthControlResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RelativeLengthControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RelativeLengthControl(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::RelativeLengthControlRequest* /*request*/, ::mavsdk::rpc::winch::RelativeLengthControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RelativeLengthControl(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::winch::RelativeLengthControlRequest* /*request*/, ::mavsdk::rpc::winch::RelativeLengthControlResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RateControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RateControl() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::RateControlRequest, ::mavsdk::rpc::winch::RateControlResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mavsdk::rpc::winch::RateControlRequest* request, ::mavsdk::rpc::winch::RateControlResponse* response) { return this->RateControl(context, request, response); }));}
    void SetMessageAllocatorFor_RateControl(
        ::grpc::MessageAllocator< ::mavsdk::rpc::winch::RateControlRequest, ::mavsdk::rpc::winch::RateControlResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::RateControlRequest, ::mavsdk::rpc::winch::RateControlResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RateControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RateControl(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::RateControlRequest* /*request*/, ::mavsdk::rpc::winch::RateControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RateControl(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::winch::RateControlRequest* /*request*/, ::mavsdk::rpc::winch::RateControlResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Lock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Lock() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::LockRequest, ::mavsdk::rpc::winch::LockResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mavsdk::rpc::winch::LockRequest* request, ::mavsdk::rpc::winch::LockResponse* response) { return this->Lock(context, request, response); }));}
    void SetMessageAllocatorFor_Lock(
        ::grpc::MessageAllocator< ::mavsdk::rpc::winch::LockRequest, ::mavsdk::rpc::winch::LockResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::LockRequest, ::mavsdk::rpc::winch::LockResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Lock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Lock(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::LockRequest* /*request*/, ::mavsdk::rpc::winch::LockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Lock(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::winch::LockRequest* /*request*/, ::mavsdk::rpc::winch::LockResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Deliver : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Deliver() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::DeliverRequest, ::mavsdk::rpc::winch::DeliverResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mavsdk::rpc::winch::DeliverRequest* request, ::mavsdk::rpc::winch::DeliverResponse* response) { return this->Deliver(context, request, response); }));}
    void SetMessageAllocatorFor_Deliver(
        ::grpc::MessageAllocator< ::mavsdk::rpc::winch::DeliverRequest, ::mavsdk::rpc::winch::DeliverResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::DeliverRequest, ::mavsdk::rpc::winch::DeliverResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Deliver() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Deliver(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::DeliverRequest* /*request*/, ::mavsdk::rpc::winch::DeliverResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Deliver(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::winch::DeliverRequest* /*request*/, ::mavsdk::rpc::winch::DeliverResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Hold : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Hold() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::HoldRequest, ::mavsdk::rpc::winch::HoldResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mavsdk::rpc::winch::HoldRequest* request, ::mavsdk::rpc::winch::HoldResponse* response) { return this->Hold(context, request, response); }));}
    void SetMessageAllocatorFor_Hold(
        ::grpc::MessageAllocator< ::mavsdk::rpc::winch::HoldRequest, ::mavsdk::rpc::winch::HoldResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::HoldRequest, ::mavsdk::rpc::winch::HoldResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Hold() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Hold(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::HoldRequest* /*request*/, ::mavsdk::rpc::winch::HoldResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Hold(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::winch::HoldRequest* /*request*/, ::mavsdk::rpc::winch::HoldResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Retract : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Retract() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::RetractRequest, ::mavsdk::rpc::winch::RetractResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mavsdk::rpc::winch::RetractRequest* request, ::mavsdk::rpc::winch::RetractResponse* response) { return this->Retract(context, request, response); }));}
    void SetMessageAllocatorFor_Retract(
        ::grpc::MessageAllocator< ::mavsdk::rpc::winch::RetractRequest, ::mavsdk::rpc::winch::RetractResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::RetractRequest, ::mavsdk::rpc::winch::RetractResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Retract() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Retract(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::RetractRequest* /*request*/, ::mavsdk::rpc::winch::RetractResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Retract(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::winch::RetractRequest* /*request*/, ::mavsdk::rpc::winch::RetractResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_LoadLine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_LoadLine() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::LoadLineRequest, ::mavsdk::rpc::winch::LoadLineResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mavsdk::rpc::winch::LoadLineRequest* request, ::mavsdk::rpc::winch::LoadLineResponse* response) { return this->LoadLine(context, request, response); }));}
    void SetMessageAllocatorFor_LoadLine(
        ::grpc::MessageAllocator< ::mavsdk::rpc::winch::LoadLineRequest, ::mavsdk::rpc::winch::LoadLineResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::LoadLineRequest, ::mavsdk::rpc::winch::LoadLineResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_LoadLine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadLine(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::LoadLineRequest* /*request*/, ::mavsdk::rpc::winch::LoadLineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LoadLine(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::winch::LoadLineRequest* /*request*/, ::mavsdk::rpc::winch::LoadLineResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_AbandonLine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_AbandonLine() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::AbandonLineRequest, ::mavsdk::rpc::winch::AbandonLineResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mavsdk::rpc::winch::AbandonLineRequest* request, ::mavsdk::rpc::winch::AbandonLineResponse* response) { return this->AbandonLine(context, request, response); }));}
    void SetMessageAllocatorFor_AbandonLine(
        ::grpc::MessageAllocator< ::mavsdk::rpc::winch::AbandonLineRequest, ::mavsdk::rpc::winch::AbandonLineResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::AbandonLineRequest, ::mavsdk::rpc::winch::AbandonLineResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_AbandonLine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AbandonLine(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::AbandonLineRequest* /*request*/, ::mavsdk::rpc::winch::AbandonLineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AbandonLine(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::winch::AbandonLineRequest* /*request*/, ::mavsdk::rpc::winch::AbandonLineResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_LoadPayload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_LoadPayload() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::LoadPayloadRequest, ::mavsdk::rpc::winch::LoadPayloadResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::mavsdk::rpc::winch::LoadPayloadRequest* request, ::mavsdk::rpc::winch::LoadPayloadResponse* response) { return this->LoadPayload(context, request, response); }));}
    void SetMessageAllocatorFor_LoadPayload(
        ::grpc::MessageAllocator< ::mavsdk::rpc::winch::LoadPayloadRequest, ::mavsdk::rpc::winch::LoadPayloadResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::winch::LoadPayloadRequest, ::mavsdk::rpc::winch::LoadPayloadResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_LoadPayload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadPayload(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::LoadPayloadRequest* /*request*/, ::mavsdk::rpc::winch::LoadPayloadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LoadPayload(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::winch::LoadPayloadRequest* /*request*/, ::mavsdk::rpc::winch::LoadPayloadResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_SubscribeStatus<WithCallbackMethod_Relax<WithCallbackMethod_RelativeLengthControl<WithCallbackMethod_RateControl<WithCallbackMethod_Lock<WithCallbackMethod_Deliver<WithCallbackMethod_Hold<WithCallbackMethod_Retract<WithCallbackMethod_LoadLine<WithCallbackMethod_AbandonLine<WithCallbackMethod_LoadPayload<Service > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_SubscribeStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubscribeStatus() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_SubscribeStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeStatus(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::SubscribeStatusRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::winch::StatusResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Relax : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Relax() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_Relax() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Relax(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::RelaxRequest* /*request*/, ::mavsdk::rpc::winch::RelaxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RelativeLengthControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RelativeLengthControl() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_RelativeLengthControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RelativeLengthControl(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::RelativeLengthControlRequest* /*request*/, ::mavsdk::rpc::winch::RelativeLengthControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RateControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RateControl() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_RateControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RateControl(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::RateControlRequest* /*request*/, ::mavsdk::rpc::winch::RateControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Lock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Lock() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_Lock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Lock(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::LockRequest* /*request*/, ::mavsdk::rpc::winch::LockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Deliver : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Deliver() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_Deliver() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Deliver(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::DeliverRequest* /*request*/, ::mavsdk::rpc::winch::DeliverResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Hold : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Hold() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_Hold() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Hold(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::HoldRequest* /*request*/, ::mavsdk::rpc::winch::HoldResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Retract : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Retract() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_Retract() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Retract(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::RetractRequest* /*request*/, ::mavsdk::rpc::winch::RetractResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LoadLine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LoadLine() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_LoadLine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadLine(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::LoadLineRequest* /*request*/, ::mavsdk::rpc::winch::LoadLineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AbandonLine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AbandonLine() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_AbandonLine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AbandonLine(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::AbandonLineRequest* /*request*/, ::mavsdk::rpc::winch::AbandonLineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LoadPayload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LoadPayload() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_LoadPayload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadPayload(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::LoadPayloadRequest* /*request*/, ::mavsdk::rpc::winch::LoadPayloadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubscribeStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubscribeStatus() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_SubscribeStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeStatus(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::SubscribeStatusRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::winch::StatusResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Relax : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Relax() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_Relax() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Relax(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::RelaxRequest* /*request*/, ::mavsdk::rpc::winch::RelaxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRelax(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RelativeLengthControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RelativeLengthControl() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_RelativeLengthControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RelativeLengthControl(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::RelativeLengthControlRequest* /*request*/, ::mavsdk::rpc::winch::RelativeLengthControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRelativeLengthControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RateControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RateControl() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_RateControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RateControl(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::RateControlRequest* /*request*/, ::mavsdk::rpc::winch::RateControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRateControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Lock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Lock() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_Lock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Lock(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::LockRequest* /*request*/, ::mavsdk::rpc::winch::LockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Deliver : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Deliver() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_Deliver() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Deliver(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::DeliverRequest* /*request*/, ::mavsdk::rpc::winch::DeliverResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeliver(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Hold : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Hold() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_Hold() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Hold(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::HoldRequest* /*request*/, ::mavsdk::rpc::winch::HoldResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHold(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Retract : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Retract() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_Retract() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Retract(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::RetractRequest* /*request*/, ::mavsdk::rpc::winch::RetractResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRetract(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LoadLine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LoadLine() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_LoadLine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadLine(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::LoadLineRequest* /*request*/, ::mavsdk::rpc::winch::LoadLineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLoadLine(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AbandonLine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AbandonLine() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_AbandonLine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AbandonLine(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::AbandonLineRequest* /*request*/, ::mavsdk::rpc::winch::AbandonLineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAbandonLine(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LoadPayload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LoadPayload() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_LoadPayload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadPayload(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::LoadPayloadRequest* /*request*/, ::mavsdk::rpc::winch::LoadPayloadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLoadPayload(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SubscribeStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SubscribeStatus() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->SubscribeStatus(context, request); }));
    }
    ~WithRawCallbackMethod_SubscribeStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeStatus(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::SubscribeStatusRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::winch::StatusResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Relax : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Relax() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Relax(context, request, response); }));
    }
    ~WithRawCallbackMethod_Relax() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Relax(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::RelaxRequest* /*request*/, ::mavsdk::rpc::winch::RelaxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Relax(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RelativeLengthControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RelativeLengthControl() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RelativeLengthControl(context, request, response); }));
    }
    ~WithRawCallbackMethod_RelativeLengthControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RelativeLengthControl(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::RelativeLengthControlRequest* /*request*/, ::mavsdk::rpc::winch::RelativeLengthControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RelativeLengthControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RateControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RateControl() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RateControl(context, request, response); }));
    }
    ~WithRawCallbackMethod_RateControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RateControl(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::RateControlRequest* /*request*/, ::mavsdk::rpc::winch::RateControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RateControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Lock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Lock() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Lock(context, request, response); }));
    }
    ~WithRawCallbackMethod_Lock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Lock(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::LockRequest* /*request*/, ::mavsdk::rpc::winch::LockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Lock(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Deliver : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Deliver() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Deliver(context, request, response); }));
    }
    ~WithRawCallbackMethod_Deliver() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Deliver(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::DeliverRequest* /*request*/, ::mavsdk::rpc::winch::DeliverResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Deliver(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Hold : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Hold() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Hold(context, request, response); }));
    }
    ~WithRawCallbackMethod_Hold() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Hold(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::HoldRequest* /*request*/, ::mavsdk::rpc::winch::HoldResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Hold(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Retract : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Retract() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Retract(context, request, response); }));
    }
    ~WithRawCallbackMethod_Retract() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Retract(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::RetractRequest* /*request*/, ::mavsdk::rpc::winch::RetractResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Retract(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_LoadLine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_LoadLine() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LoadLine(context, request, response); }));
    }
    ~WithRawCallbackMethod_LoadLine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadLine(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::LoadLineRequest* /*request*/, ::mavsdk::rpc::winch::LoadLineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LoadLine(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_AbandonLine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_AbandonLine() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AbandonLine(context, request, response); }));
    }
    ~WithRawCallbackMethod_AbandonLine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AbandonLine(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::AbandonLineRequest* /*request*/, ::mavsdk::rpc::winch::AbandonLineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AbandonLine(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_LoadPayload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_LoadPayload() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LoadPayload(context, request, response); }));
    }
    ~WithRawCallbackMethod_LoadPayload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadPayload(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::LoadPayloadRequest* /*request*/, ::mavsdk::rpc::winch::LoadPayloadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LoadPayload(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Relax : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Relax() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mavsdk::rpc::winch::RelaxRequest, ::mavsdk::rpc::winch::RelaxResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mavsdk::rpc::winch::RelaxRequest, ::mavsdk::rpc::winch::RelaxResponse>* streamer) {
                       return this->StreamedRelax(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Relax() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Relax(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::RelaxRequest* /*request*/, ::mavsdk::rpc::winch::RelaxResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRelax(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mavsdk::rpc::winch::RelaxRequest,::mavsdk::rpc::winch::RelaxResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RelativeLengthControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RelativeLengthControl() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mavsdk::rpc::winch::RelativeLengthControlRequest, ::mavsdk::rpc::winch::RelativeLengthControlResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mavsdk::rpc::winch::RelativeLengthControlRequest, ::mavsdk::rpc::winch::RelativeLengthControlResponse>* streamer) {
                       return this->StreamedRelativeLengthControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RelativeLengthControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RelativeLengthControl(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::RelativeLengthControlRequest* /*request*/, ::mavsdk::rpc::winch::RelativeLengthControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRelativeLengthControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mavsdk::rpc::winch::RelativeLengthControlRequest,::mavsdk::rpc::winch::RelativeLengthControlResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RateControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RateControl() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mavsdk::rpc::winch::RateControlRequest, ::mavsdk::rpc::winch::RateControlResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mavsdk::rpc::winch::RateControlRequest, ::mavsdk::rpc::winch::RateControlResponse>* streamer) {
                       return this->StreamedRateControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RateControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RateControl(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::RateControlRequest* /*request*/, ::mavsdk::rpc::winch::RateControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRateControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mavsdk::rpc::winch::RateControlRequest,::mavsdk::rpc::winch::RateControlResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Lock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Lock() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mavsdk::rpc::winch::LockRequest, ::mavsdk::rpc::winch::LockResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mavsdk::rpc::winch::LockRequest, ::mavsdk::rpc::winch::LockResponse>* streamer) {
                       return this->StreamedLock(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Lock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Lock(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::LockRequest* /*request*/, ::mavsdk::rpc::winch::LockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mavsdk::rpc::winch::LockRequest,::mavsdk::rpc::winch::LockResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Deliver : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Deliver() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mavsdk::rpc::winch::DeliverRequest, ::mavsdk::rpc::winch::DeliverResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mavsdk::rpc::winch::DeliverRequest, ::mavsdk::rpc::winch::DeliverResponse>* streamer) {
                       return this->StreamedDeliver(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Deliver() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Deliver(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::DeliverRequest* /*request*/, ::mavsdk::rpc::winch::DeliverResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeliver(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mavsdk::rpc::winch::DeliverRequest,::mavsdk::rpc::winch::DeliverResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Hold : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Hold() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mavsdk::rpc::winch::HoldRequest, ::mavsdk::rpc::winch::HoldResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mavsdk::rpc::winch::HoldRequest, ::mavsdk::rpc::winch::HoldResponse>* streamer) {
                       return this->StreamedHold(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Hold() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Hold(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::HoldRequest* /*request*/, ::mavsdk::rpc::winch::HoldResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedHold(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mavsdk::rpc::winch::HoldRequest,::mavsdk::rpc::winch::HoldResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Retract : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Retract() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mavsdk::rpc::winch::RetractRequest, ::mavsdk::rpc::winch::RetractResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mavsdk::rpc::winch::RetractRequest, ::mavsdk::rpc::winch::RetractResponse>* streamer) {
                       return this->StreamedRetract(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Retract() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Retract(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::RetractRequest* /*request*/, ::mavsdk::rpc::winch::RetractResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRetract(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mavsdk::rpc::winch::RetractRequest,::mavsdk::rpc::winch::RetractResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LoadLine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LoadLine() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mavsdk::rpc::winch::LoadLineRequest, ::mavsdk::rpc::winch::LoadLineResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mavsdk::rpc::winch::LoadLineRequest, ::mavsdk::rpc::winch::LoadLineResponse>* streamer) {
                       return this->StreamedLoadLine(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LoadLine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LoadLine(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::LoadLineRequest* /*request*/, ::mavsdk::rpc::winch::LoadLineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLoadLine(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mavsdk::rpc::winch::LoadLineRequest,::mavsdk::rpc::winch::LoadLineResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AbandonLine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AbandonLine() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mavsdk::rpc::winch::AbandonLineRequest, ::mavsdk::rpc::winch::AbandonLineResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mavsdk::rpc::winch::AbandonLineRequest, ::mavsdk::rpc::winch::AbandonLineResponse>* streamer) {
                       return this->StreamedAbandonLine(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AbandonLine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AbandonLine(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::AbandonLineRequest* /*request*/, ::mavsdk::rpc::winch::AbandonLineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAbandonLine(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mavsdk::rpc::winch::AbandonLineRequest,::mavsdk::rpc::winch::AbandonLineResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LoadPayload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LoadPayload() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mavsdk::rpc::winch::LoadPayloadRequest, ::mavsdk::rpc::winch::LoadPayloadResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mavsdk::rpc::winch::LoadPayloadRequest, ::mavsdk::rpc::winch::LoadPayloadResponse>* streamer) {
                       return this->StreamedLoadPayload(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LoadPayload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LoadPayload(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::LoadPayloadRequest* /*request*/, ::mavsdk::rpc::winch::LoadPayloadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLoadPayload(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mavsdk::rpc::winch::LoadPayloadRequest,::mavsdk::rpc::winch::LoadPayloadResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Relax<WithStreamedUnaryMethod_RelativeLengthControl<WithStreamedUnaryMethod_RateControl<WithStreamedUnaryMethod_Lock<WithStreamedUnaryMethod_Deliver<WithStreamedUnaryMethod_Hold<WithStreamedUnaryMethod_Retract<WithStreamedUnaryMethod_LoadLine<WithStreamedUnaryMethod_AbandonLine<WithStreamedUnaryMethod_LoadPayload<Service > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_SubscribeStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_SubscribeStatus() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::mavsdk::rpc::winch::SubscribeStatusRequest, ::mavsdk::rpc::winch::StatusResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::mavsdk::rpc::winch::SubscribeStatusRequest, ::mavsdk::rpc::winch::StatusResponse>* streamer) {
                       return this->StreamedSubscribeStatus(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_SubscribeStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubscribeStatus(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::winch::SubscribeStatusRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::winch::StatusResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSubscribeStatus(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::mavsdk::rpc::winch::SubscribeStatusRequest,::mavsdk::rpc::winch::StatusResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_SubscribeStatus<Service > SplitStreamedService;
  typedef WithSplitStreamingMethod_SubscribeStatus<WithStreamedUnaryMethod_Relax<WithStreamedUnaryMethod_RelativeLengthControl<WithStreamedUnaryMethod_RateControl<WithStreamedUnaryMethod_Lock<WithStreamedUnaryMethod_Deliver<WithStreamedUnaryMethod_Hold<WithStreamedUnaryMethod_Retract<WithStreamedUnaryMethod_LoadLine<WithStreamedUnaryMethod_AbandonLine<WithStreamedUnaryMethod_LoadPayload<Service > > > > > > > > > > > StreamedService;
};

}  // namespace winch
}  // namespace rpc
}  // namespace mavsdk


#endif  // GRPC_winch_2fwinch_2eproto__INCLUDED
